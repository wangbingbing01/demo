记录时间: 2025-08-26

文件说明: 本文档记录了用户与 AI 的问答，涵盖了本仓库 `MockKit`（mocker）的用途、`verify` 方法的实现细节，以及如何用本项目的 MockKit 模拟 Mockito 的 matcher/verify 场景。

---

问题 1：什么是 mocker？

回答：
- `mocker` 通常是 `MockKit` 的实例（例：`let mocker = new MockKit();`）。
- 用途：MockKit 用于函数级 mocking：替换对象的方法以便在测试中控制返回值、动作或抛错，并记录/验证调用情况。
- 典型 API/流程：
  1. 创建 mocker：`let mocker = new MockKit();`
  2. 创建 mock 函数：`let mockfunc = mocker.mockFunc(obj, obj.method);`
  3. 配置行为：`when(mockfunc)('arg').afterReturn('value')` / `afterReturnNothing()` / `afterThrow('msg')` / `afterAction(fn)`
  4. 验证调用：`mocker.verify(methodName, argsArray).times(n)` / `.once()` / `.atLeast(x)` / `.atMost(x)` / `.never()`
  5. 还原或清理：`mocker.ignoreMock(obj, method)` / `mocker.clear()` / `mocker.clearAll()`
- 支持参数匹配器用于 stub：`ArgumentMatchers.any`, `anyString`, `matchRegexs(...)`（用于 `when(mockfunc)(ArgumentMatchers.any).afterReturn(...)`），但 `verify` 本身不接受 matcher。
- 相关实现位置：`jsunit/src/module/mock/MockKit.js`, `VerificationMode.js`, `ArgumentMatchers.js`。

示例（摘自 README）：

let mocker = new MockKit();
class ClassName { method_1(arg){ return '888888'; } }
let claser = new ClassName();
let mockfunc = mocker.mockFunc(claser, claser.method_1);
when(mockfunc)('test').afterReturn('1');
expect(claser.method_1('test')).assertEqual('1');
mocker.ignoreMock(claser, claser.method_1); // 恢复原函数

---

问题 2：`mocker.verify` 方法是怎么用的？

回答：
- 实现位置：`jsunit/src/module/mock/MockKit.js` 的 `verify` 函数；断言实现位于 `jsunit/src/module/mock/VerificationMode.js`。
- `verify` 签名与行为：`mocker.verify(methodName, argsArray)`，返回 `VerificationMode` 实例。
  - `methodName` 是函数名字符串（例如 "method_1"）。
  - `argsArray` 是参数数组，用来构造 key（基于 `Array.toString()` 拼接）。
- 内部实现细节：
  - MockKit 在记录调用时的 key 格式是：`methodName + '(' + Array.from(args).toString() + ')'`，例如 `method_1(a,2)`。
  - `verify` 根据你传的 `methodName` 和 `argsArray.toString()` 拼接的 key 在 `recordCalls` Map 中查找次数，没找到计为 0，然后创建 `VerificationMode(times)`。
- `VerificationMode` 可用断言方法：`times(count)`, `once()`, `never()`, `atLeast(count)`, `atMost(count)`。
- 限制：`verify` 匹配基于 args 的 `toString()` 值，因此对对象/数组/复杂类型不可靠。

示例：
// 记录了两次调用带参数 'test'
mocker.verify('method_1', ['test']).times(2);

建议：对复杂对象建议使用 `afterAction` 记录结构化参数并做验证（见下）。

---

问题 3：给出一段 Mockito 的 Java 示例，并说明如何用当前项目 MockKit 实现类似效果：

Mockito 代码：
Mockito.verify(mockedList, atMost(2)).add(argThat(new ArgumentMatcher<Person>() {
    @Override
    public boolean matches(Object o) {
        if (!(o instanceof Person)) {
            return false;
        }
        return ((Person) o).getAge() < 20;
    }
}));

解释：
- 断言 `mockedList.add(...)` 在最多 2 次调用中，且每次的参数满足 matcher（参数是 `Person` 且 `age < 20`）。

用 MockKit 实现的可行方案与示例：

推荐方案（可靠）：在 mock 的 `afterAction` 中计数，最后断言计数 <= 2。优点：能够直接检查对象属性（例如 `getAge()`），不依赖 `toString()`。

示例代码（JS）：
import { MockKit, when } from '@ohos/hypium';
import { expect } from '@ohos/hypium';

const mocker = new MockKit();
class Person { constructor(age){ this.age = age } getAge(){ return this.age } }
const list = { add(item) {} };
const mockAdd = mocker.mockFunc(list, list.add);
let matchedCount = 0;
when(mockAdd)(ArgumentMatchers.any).afterAction(function(arg) {
  const age = (typeof arg.getAge === 'function') ? arg.getAge() : arg.age;
  if (typeof age === 'number' && age < 20) {
    matchedCount++;
  }
});

// 被测代码调用
list.add(new Person(18));
list.add(new Person(25));
list.add(new Person(17));

// 断言
expect(matchedCount).assertLessOrEqual(2);

备选方案 A（依赖具体实例或可控 toString）：
const p = new Person(18);
list.add(p);
mocker.verify('add', [p]).atMost(2);

备选方案 B（扩展/修改 MockKit）：
- 在 MockKit 内新增结构化记录（push 调用参数到数组），或添加 `verifyWithMatcher` 工具函数来遍历记录并应用 matcher 函数。

建议总结：
- 推荐使用 `afterAction` 记录结构化参数并计数；只有在能保证参数字符串化稳定时，才使用 `mocker.verify` 的现有字符串匹配。
- 如果需要，我可以把 `verifyWithMatcher` 工具或实际测试文件写入仓库（需指示）。

---

如果你希望我把这些示例转换为实际的单元测试文件并提交到仓库里，请回复并指明你偏好的文件位置（例如 `jsunit/test/samples/mockkit_matcher_test.js`）。


